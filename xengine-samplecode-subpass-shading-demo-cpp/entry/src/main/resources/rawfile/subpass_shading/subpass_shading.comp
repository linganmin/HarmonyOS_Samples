#version 450

#extension GL_HUAWEI_subpass_shading : require
#extension GL_KHR_shader_subgroup_arithmetic : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

struct ViewFrustum
{
    vec4 planes[6];
    vec3 points[8];
};

struct PointLight
{
    vec3 pos;
    float radius;
    vec3 intensity;
};

struct LightVisiblity
{
    uint count;
    uint lightindices[1023];
};

layout(set = 1, binding = 1, std430) readonly buffer CameraUbo
{
    mat4 view;
    mat4 proj;
    mat4 projview;
    vec3 cam_pos;
} camera;

layout(set = 0, binding = 1, std430) readonly buffer PointLights
{
    int light_num;
    PointLight pointlights[2000];
} _705;

layout(set = 0, binding = 0, std430) writeonly buffer TileLightVisiblities
{
    LightVisiblity light_visiblities[];
} _745;

layout(push_constant, std430) uniform PushConstantObject
{
    ivec2 viewport_size;
    ivec2 tile_nums;
} push_constants;

layout(input_attachment_index = 0, set = 2, binding = 0) uniform subpassInput depthAttachment;

shared float min_depth;
shared float max_depth;
shared ViewFrustum frustum;
shared uint light_count_for_tile;

ViewFrustum createFrustum(ivec2 tile_id)
{
    mat4 inv_projview = camera.projview;
    vec2 ndc_size_per_tile = vec2(16.0) / vec2(push_constants.viewport_size);
    vec2 ndc_pts[4];
    ndc_pts[0] = vec2(-1.0) + (vec2(tile_id) * ndc_size_per_tile);
    ndc_pts[1] = vec2(ndc_pts[0].x + ndc_size_per_tile.x, ndc_pts[0].y);
    ndc_pts[2] = ndc_pts[0] + ndc_size_per_tile;
    ndc_pts[3] = vec2(ndc_pts[0].x, ndc_pts[0].y + ndc_size_per_tile.y);
    vec4 temp = inv_projview * vec4(ndc_pts[0], min_depth, 1.0);
    ViewFrustum frustum_1;
    frustum_1.points[0] = temp.xyz / vec3(temp.w);
    temp = inv_projview * vec4(ndc_pts[0], max_depth, 1.0);
    frustum_1.points[4] = temp.xyz / vec3(temp.w);
    temp = inv_projview * vec4(ndc_pts[1], min_depth, 1.0);
    frustum_1.points[1] = temp.xyz / vec3(temp.w);
    temp = inv_projview * vec4(ndc_pts[1], max_depth, 1.0);
    frustum_1.points[5] = temp.xyz / vec3(temp.w);
    temp = inv_projview * vec4(ndc_pts[2], min_depth, 1.0);
    frustum_1.points[2] = temp.xyz / vec3(temp.w);
    temp = inv_projview * vec4(ndc_pts[2], max_depth, 1.0);
    frustum_1.points[6] = temp.xyz / vec3(temp.w);
    temp = inv_projview * vec4(ndc_pts[3], min_depth, 1.0);
    frustum_1.points[3] = temp.xyz / vec3(temp.w);
    temp = inv_projview * vec4(ndc_pts[3], max_depth, 1.0);
    frustum_1.points[7] = temp.xyz / vec3(temp.w);
    vec3 temp_normal = normalize(cross(frustum_1.points[0] - camera.cam_pos, frustum_1.points[1] - camera.cam_pos));
    frustum_1.planes[0] = vec4(temp_normal, -dot(temp_normal, frustum_1.points[0]));
    temp_normal = normalize(cross(frustum_1.points[1] - camera.cam_pos, frustum_1.points[2] - camera.cam_pos));
    frustum_1.planes[1] = vec4(temp_normal, -dot(temp_normal, frustum_1.points[1]));
    temp_normal = normalize(cross(frustum_1.points[2] - camera.cam_pos, frustum_1.points[3] - camera.cam_pos));
    frustum_1.planes[2] = vec4(temp_normal, -dot(temp_normal, frustum_1.points[2]));
    temp_normal = normalize(cross(frustum_1.points[3] - camera.cam_pos, frustum_1.points[4] - camera.cam_pos));
    frustum_1.planes[3] = vec4(temp_normal, -dot(temp_normal, frustum_1.points[3]));
    temp_normal = normalize(cross(frustum_1.points[1] - frustum_1.points[0], frustum_1.points[3] - frustum_1.points[0]));
    frustum_1.planes[4] = vec4(temp_normal, -dot(temp_normal, frustum_1.points[0]));
    temp_normal = normalize(cross(frustum_1.points[7] - frustum_1.points[4], frustum_1.points[5] - frustum_1.points[4]));
    frustum_1.planes[5] = vec4(temp_normal, -dot(temp_normal, frustum_1.points[4]));
    return frustum_1;
}

bool isCollided(PointLight light, ViewFrustum frustum_1)
{
    if ((dot(light.pos, frustum_1.planes[0].xyz) + frustum_1.planes[0].w) < (-light.radius))
    {
        return false;
    }
    if ((dot(light.pos, frustum_1.planes[1].xyz) + frustum_1.planes[1].w) < (-light.radius))
    {
        return false;
    }
    if ((dot(light.pos, frustum_1.planes[2].xyz) + frustum_1.planes[2].w) < (-light.radius))
    {
        return false;
    }
    if ((dot(light.pos, frustum_1.planes[3].xyz) + frustum_1.planes[3].w) < (-light.radius))
    {
        return false;
    }
    if ((dot(light.pos, frustum_1.planes[4].xyz) + frustum_1.planes[4].w) < (-light.radius))
    {
        return false;
    }
    if ((dot(light.pos, frustum_1.planes[5].xyz) + frustum_1.planes[5].w) < (-light.radius))
    {
        return false;
    }
    vec3 light_bbox_max = light.pos + vec3(light.radius);
    vec3 light_bbox_min = light.pos - vec3(light.radius);
    int probe = 0;
    for (int i = 0; i < 8; i++)
    {
        probe += int(frustum_1.points[i].x > light_bbox_max.x);
    }
    if (probe == 8)
    {
        return false;
    }
    probe = 0;
    for (int i_1 = 0; i_1 < 8; i_1++)
    {
        probe += int(frustum_1.points[i_1].x < light_bbox_min.x);
    }
    if (probe == 8)
    {
        return false;
    }
    probe = 0;
    for (int i_2 = 0; i_2 < 8; i_2++)
    {
        probe += int(frustum_1.points[i_2].y > light_bbox_max.y);
    }
    if (probe == 8)
    {
        return false;
    }
    probe = 0;
    for (int i_3 = 0; i_3 < 8; i_3++)
    {
        probe += int(frustum_1.points[i_3].y < light_bbox_min.y);
    }
    if (probe == 8)
    {
        return false;
    }
    probe = 0;
    for (int i_4 = 0; i_4 < 8; i_4++)
    {
        probe += int(frustum_1.points[i_4].z > light_bbox_max.z);
    }
    if (probe == 8)
    {
        return false;
    }
    probe = 0;
    for (int i_5 = 0; i_5 < 8; i_5++)
    {
        probe += int(frustum_1.points[i_5].z < light_bbox_min.z);
    }
    if (probe == 8)
    {
        return false;
    }
    return true;
}

void main()
{
    ivec2 tile_id = ivec2(gl_GlobalInvocationID.xy / 8);
    float depth = subpassLoad(depthAttachment).x;
    float minDepth = subgroupMin(depth);
    float maxDepth = subgroupMax(depth);
    if (gl_LocalInvocationIndex == 0u)
    {
        min_depth = min(1.0, minDepth);
        max_depth = max(0.0, maxDepth);
        if (min_depth >= max_depth)
        {
            min_depth = max_depth;
        }
        ivec2 param = tile_id;
        frustum = createFrustum(param);
        light_count_for_tile = 0u;
    }
    groupMemoryBarrier();
    uint tile_index = uint((tile_id.y * push_constants.tile_nums.x) + tile_id.x);
    uint i = gl_LocalInvocationIndex;
    for (;;)
    {
        uint _699 = i;
        int _708 = _705.light_num;
        bool _710 = _699 < uint(_708);
        bool _716;
        if (_710)
        {
            _716 = light_count_for_tile < 1023u;
        }
        else
        {
            _716 = _710;
        }
        if (_716)
        {
            PointLight param_1;
            param_1.pos = _705.pointlights[i].pos;
            param_1.radius = _705.pointlights[i].radius;
            param_1.intensity = _705.pointlights[i].intensity;
            ViewFrustum param_2 = frustum;
            if (isCollided(param_1, param_2))
            {
                uint _734 = atomicAdd(light_count_for_tile, 1u);
                uint slot = _734;
                if (slot >= 1023u)
                {
                    break;
                }
                _745.light_visiblities[tile_index].lightindices[slot] = i;
            }
            i += 64u;
            continue;
        }
        else
        {
            break;
        }
    }
    groupMemoryBarrier();
    if (gl_LocalInvocationIndex == 0u)
    {
        _745.light_visiblities[tile_index].count = min(1023u, light_count_for_tile);
    }
}

